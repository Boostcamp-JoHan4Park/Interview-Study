### 시간, 공간 복잡도

- 시간복잡도: 알고리즘의 수행시간을 평가

  - 최선의 경우 (Best Case)
    - 빅 오메가 표기법 사용
    - 최선의 시나리오로 최소 이만한 시간이 걸림
  - 최악의 경우 (Worst Case)
    - 빅 오 표기법 사용
    - 최악의 시나리오로 아무리 오래 걸려도 이 시간보다 덜 걸림
  - 평균적인 경우 (Average Case)
    - 빅 세타 표기법 사용
    - 평균 시간을 나타냄
  - Big O notation: 연산 횟수가 다항식으로 표현될 경우, 최고차항을 제외한 모든 항과 최고차항의 계수를 제외시켜 나타냄

- 공간복잡도: 알고리즘 수행에 필요한 메모리 양을 평가  
  보조공간(Auxiliary Space)과 입력 공간(input size)을 합친 포괄적인 개념  
  시간 복잡도와 유사하게 빅오 표기법을 사용

### Sort Algorithm

- Bubble Sort 버블 정렬: 1번째와 2번째 원소를 비교하여 정렬하고, 2번째와 3번째, ..., n-1번째와 n번째를 정렬한 뒤 다시 처음으로 돌아가 이번에는 n-2번째와 n-1번째까지, ...해서 최대 ${n(n-1)}/{2}$ 번 정렬  
  시간복잡도는 $O(n^2)$, 공간복잡도는 $O(n)$

- Selection Sort 선택정렬: 1번째부터 끝까지 훑어서 가장 작은 게 1번째, 2번째부터 끝까지 훑어서 가장 작은 게 2번째……해서 (n-1)번 반복  
  시간복잡도는 $O(n^2)$, 공간복잡도는 $O(n)$

- Insertion Sort 삽입정렬: k번째 원소를 1부터 k-1까지와 비교해 적절한 위치에 끼워넣고 그 뒤의 자료를 한 칸씩 뒤로 밀어내는 방식  
  시간복잡도는 $O(n^2)$, 공간복잡도는 $O(n)$

- Merge Sort 병합정렬: 원소 개수가 1 또는 0이 될 때까지 두 부분으로 쪼개고 쪼개서 자른 순서의 역순으로 크기를 비교해 병합  
  대표적인 stable sort
  시간복잡도는 $O(nlogn)$, 공간복잡도는 $O(2n)$

- Heap Sort 힙정렬: 원소들을 힙에 모두 넣고 힙이 빌 때까지 루트를 출력  
  Quick sort에 비해 휴리스틱 없이도 일정한 성능을 보일 수 있다는 장점  
  시간복잡도는 $O(nlogn)$, 공간복잡도는 $O(n)$

- Quick Sort 퀵정렬: 적절한 원소 하나를 기준(피벗, pivot)으로 삼아 그보다 작은 것을 앞으로 빼내고 그 뒤에 피벗을 옮겨 피벗보다 작은 것, 큰 것으로 나눈뒤 나누어진 각각에서 다시 피벗을 잡고 정렬해서 각각의 크기가 0이나 1이 될 때까지 정렬

- Counting Sort 계수정렬: 특정 데이터의 개수(1이 두 개 있다면 2)를 데이터의 값에 대응하는 위치에 저장한 뒤, 자신의 위치에서 앞에 있던 값을 모두 더한 배열을 만든 뒤, 거기서 데이터가 들어가야 할 위치를 찾아내는 정렬 알고리즘  
   배열을 사용하는 특성상, 정수를 전제로 함  
  시간복잡도는 $O(n+k)$ ($k$는 데이터의 최댓값)

- Radix Sort 기수정렬: 자릿수가 있는 데이터(정수, 문자열 등)에서만 수행이 가능하며, 데이터끼리의 직접적인 비교 없이 정렬을 수행  
  자릿수가 적은 4바이트 정수 등에서나 제대로 된 성능을 발휘할 수 있으며, 자릿수가 무제한에 가까운 문자열 정렬 등에 사용할 경우 오히려 퀵정렬보다 느릴 수 있고, 부동 소수점의 경우는 부호여부, 지수부, 가수부에 대해 각각 기수정렬을 실행  
  시간복잡도는 $O(kn)$ ($k$는 데이터의 자릿수), 공간복잡도는 $O(n)$
  1. 0~9 까지의 Bucket(Queue 자료구조의)을 준비한다.
  2. 모든 데이터에 대하여 가장 낮은 자리수에 해당하는 Bucket에 차례대로 데이터를 둔다.
  3. 0부터 차례대로 버킷에서 데이터를 다시 가져온다.
  4. 가장 높은 자리수를 기준으로 하여 자리수를 높여가며 2번 3번 과정을 반복한다.
